{"version":3,"sources":["webpack://PhaserNavMeshPlugin/webpack/universalModuleDefinition","webpack://PhaserNavMeshPlugin/../node_modules/javascript-astar/astar.js","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/math/vector-2.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/navpoly.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/utils.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/channel.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/math/line.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/math/polygon.ts","webpack://PhaserNavMeshPlugin/./phaser-navmesh.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/navmesh.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/navgraph.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/map-parsers/point-queue.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/map-parsers/rectangle-hull.ts","webpack://PhaserNavMeshPlugin/../node_modules/ts-loader/navmesh/src/map-parsers/build-polys-from-grid-map.ts","webpack://PhaserNavMeshPlugin/./phaser-navmesh-plugin.ts","webpack://PhaserNavMeshPlugin/./index.ts","webpack://PhaserNavMeshPlugin/external {\"root\":\"Phaser\",\"commonjs\":\"phaser\",\"commonjs2\":\"phaser\",\"amd\":\"phaser\"}","webpack://PhaserNavMeshPlugin/webpack/bootstrap","webpack://PhaserNavMeshPlugin/webpack/startup","webpack://PhaserNavMeshPlugin/webpack/runtime/compat get default export","webpack://PhaserNavMeshPlugin/webpack/runtime/define property getters","webpack://PhaserNavMeshPlugin/webpack/runtime/hasOwnProperty shorthand"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__445__","definition","pathTo","node","curr","path","parent","unshift","astar","search","graph","start","end","options","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","BinaryHeap","f","closestNode","h","markDirty","push","size","currentNode","pop","closed","neighbors","i","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","Math","abs","x","y","diagonal","D2","sqrt","d1","d2","min","cleanNode","Graph","gridIn","this","nodes","grid","row","GridNode","init","weight","scoreFunction","content","prototype","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","n","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","Vector2","v","atan2","dx","dy","NavPoly","id","polygon","edges","portals","centroid","calculateCentroid","boundingRadius","calculateRadius","points","point","contains","isPointOnEdge","forEach","p","add","d","distance","edge","pointOnSegment","navPolygon","centroidDistance","projectPointToEdge","line","a","b","l2","distanceSquared","t","value","triarea2","c","ax","ay","almostEqual","value1","value2","errorMargin","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","area2","isTruthy","input","Boolean","Channel","p1","p2","undefined","left","right","pts","apexIndex","leftIndex","rightIndex","portalApex","portalLeft","portalRight","equals","Line","x1","y1","x2","y2","max","top","bottom","pointOnLine","Polygon","isClosed","first","last","inside","ix","iy","jx","jy","PhaserNavMesh","plugin","scene","key","meshPolygonPoints","meshShrinkAmount","debugGraphics","navMesh","newPolys","map","polyPoints","vectors","navPolygons","calculateNeighbors","navPolygon1","navPolygon2","destroy","poly","some","navPoly","maxAllowableDist","Number","POSITIVE_INFINITY","minDistance","closestPoly","pointOnClosestPoly","r","projectPointToPolygon","startPoint","endPoint","startPoly","endPoly","startDistance","MAX_VALUE","endDistance","startVector","endVector","astarPath","navHeuristic","channel","nextNavPolygon","portal","Error","stringPull","lastPoint","phaserPath","newPoint","clone","otherNavPoly","otherEdge","overlap","getSegmentOverlap","edgeStartAngle","angle","a1","a2","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","isPointInMesh","PointClass","findPath","graphics","visible","clear","drawCentroid","drawBounds","drawNeighbors","drawPortals","palette","getPolygons","color","fillStyle","fillPoints","getPoints","fillCircle","lineStyle","strokeCircle","lineBetween","thickness","alpha","strokePoints","removeMesh","PointQueue","data","shift","find","every","containsPoint","findIndex","index","getIndexOfPoint","splice","removePoint","RectangleHull","tiles","fn","buildPolysFromGridMap","tileWidth","tileHeight","isWalkable","walkableQueue","hulls","currentHull","col","attemptExtension","hull","dir","neighborPoints","forEachTopPoint","forEachBottomPoint","forEachLeftPoint","forEachRightPoint","getExtensionPoints","canExtend","containsAllPoints","extendHullInDirection","removePoints","isEmpty","tile","needsExtensionCheck","extendedTop","extendedBottom","extendedLeft","extendedRight","PhaserNavMeshPlugin","pluginManager","super","phaserNavMeshes","systems","events","once","off","boot","removeAllMeshes","meshes","Object","values","m","tilemap","tilemapLayers","dataLayers","tl","layer","layers","collides","offsetX","offsetY","scaleX","scaleY","tileToWorldX","tileToWorldY","console","warn","layerIndex","rotation","walkableAreas","ty","height","tx","width","walkable","polygons","mesh","objectLayer","objects","obj","w","log","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","getter","__esModule","o","defineProperty","enumerable","get","prop","hasOwnProperty","call"],"mappings":"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","file":"phaser-navmesh-plugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"phaser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"phaser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavMeshPlugin\"] = factory(require(\"phaser\"));\n\telse\n\t\troot[\"PhaserNavMeshPlugin\"] = factory(root[\"Phaser\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__445__) {\nreturn ","// javascript-astar 0.4.2\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n(function(definition) {\n  /* global module, define */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && define.amd) {\n    define([], definition);\n  } else {\n    var exports = definition();\n    window.astar = exports.astar;\n    window.Graph = exports.Graph;\n  }\n})(function() {\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nreturn {\n  astar: astar,\n  Graph: Graph\n};\n\n});","/**\r\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Vector2\r\n */\r\nexport default class Vector2 {\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    equals(v) {\r\n        return this.x === v.x && this.y === v.y;\r\n    }\r\n    angle(v) {\r\n        return Math.atan2(v.y - this.y, v.x - this.x);\r\n    }\r\n    distance(v) {\r\n        const dx = v.x - this.x;\r\n        const dy = v.y - this.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n    }\r\n    subtract(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n    }\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n/**\r\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\r\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\r\n * toString, isWall and getCost. See GPS test from astar repo for structure:\r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n */\r\nexport default class NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     */\r\n    constructor(id, polygon) {\r\n        // jsastar property:\r\n        this.weight = 1;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = polygon.edges;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this.calculateCentroid();\r\n        this.boundingRadius = this.calculateRadius();\r\n    }\r\n    /**\r\n     * Returns an array of points that form the polygon.\r\n     */\r\n    getPoints() {\r\n        return this.polygon.points;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is within the polygon.\r\n     */\r\n    contains(point) {\r\n        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n        // check numerical stability here. It would also be good to optimize this for different shapes.\r\n        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\r\n    }\r\n    /**\r\n     * Only rectangles are supported, so this calculation works, but this is not actually the centroid\r\n     * calculation for a polygon. This is just the average of the vertices - proper centroid of a\r\n     * polygon factors in the area.\r\n     */\r\n    calculateCentroid() {\r\n        const centroid = new Vector2(0, 0);\r\n        const length = this.polygon.points.length;\r\n        this.polygon.points.forEach((p) => centroid.add(p));\r\n        centroid.x /= length;\r\n        centroid.y /= length;\r\n        return centroid;\r\n    }\r\n    /**\r\n     * Calculate the radius of a circle that circumscribes the polygon.\r\n     */\r\n    calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius)\r\n                boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is on one of the edges of the polygon.\r\n     */\r\n    isPointOnEdge({ x, y }) {\r\n        for (const edge of this.edges) {\r\n            if (edge.pointOnSegment(x, y))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    destroy() {\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n    // === jsastar methods ===\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n/**\r\n * Calculate the distance squared between two points. This is an optimization to a square root when\r\n * you just need to compare relative distances without needing to know the specific distance.\r\n * @param a\r\n * @param b\r\n */\r\nexport function distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n/**\r\n * Project a point onto a line segment.\r\n * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n * @param point\r\n * @param line\r\n */\r\nexport function projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n}\r\n/**\r\n * Twice the area of the triangle formed by a, b and c.\r\n */\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n/**\r\n * Clamp the given value between min and max.\r\n */\r\nexport function clamp(value, min, max) {\r\n    if (value < min)\r\n        value = min;\r\n    if (value > max)\r\n        value = max;\r\n    return value;\r\n}\r\n/**\r\n * Check if two values are within a small margin of one another.\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n/**\r\n * Find the smallest angle difference between two angles\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n */\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n/**\r\n * Check if two lines are collinear (within a small error margin).\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\nexport function isTruthy(input) {\r\n    return Boolean(input);\r\n}\r\n","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\nimport { triarea2 } from \"./utils\";\r\n/**\r\n * @private\r\n */\r\nexport default class Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n        this.path = [];\r\n    }\r\n    push(p1, p2) {\r\n        if (p2 === undefined)\r\n            p2 = p1;\r\n        this.portals.push({\r\n            left: p1,\r\n            right: p2,\r\n        });\r\n    }\r\n    stringPull() {\r\n        const portals = this.portals;\r\n        const pts = [];\r\n        // Init scan state\r\n        let apexIndex = 0;\r\n        let leftIndex = 0;\r\n        let rightIndex = 0;\r\n        let portalApex = portals[0].left;\r\n        let portalLeft = portals[0].left;\r\n        let portalRight = portals[0].right;\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            const left = portals[i].left;\r\n            const right = portals[i].right;\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                }\r\n                else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    // Restart scan from portal left point.\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                }\r\n                else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    // Restart scan from portal right point.\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n","import Vector2 from \"./vector-2\";\r\n/**\r\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Line\r\n */\r\nexport default class Line {\r\n    constructor(x1, y1, x2, y2) {\r\n        this.start = new Vector2(x1, y1);\r\n        this.end = new Vector2(x2, y2);\r\n        this.left = Math.min(x1, x2);\r\n        this.right = Math.max(x1, x2);\r\n        this.top = Math.min(y1, y2);\r\n        this.bottom = Math.max(y1, y2);\r\n    }\r\n    pointOnSegment(x, y) {\r\n        return (x >= this.left &&\r\n            x <= this.right &&\r\n            y >= this.top &&\r\n            y <= this.bottom &&\r\n            this.pointOnLine(x, y));\r\n    }\r\n    pointOnLine(x, y) {\r\n        // Compare slope of line start -> xy to line start -> line end\r\n        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\r\n    }\r\n}\r\n","import Line from \"./line\";\r\n/**\r\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Polygon\r\n */\r\nexport default class Polygon {\r\n    constructor(points, closed = true) {\r\n        this.isClosed = closed;\r\n        this.points = points;\r\n        this.edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        if (this.isClosed) {\r\n            const first = points[0];\r\n            const last = points[points.length - 1];\r\n            this.edges.push(new Line(first.x, first.y, last.x, last.y));\r\n        }\r\n    }\r\n    contains(x, y) {\r\n        let inside = false;\r\n        for (let i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\r\n            const ix = this.points[i].x;\r\n            const iy = this.points[i].y;\r\n            const jx = this.points[j].x;\r\n            const jy = this.points[j].y;\r\n            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&\r\n                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {\r\n                inside = !inside;\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n}\r\n","// Directly importing the TS version - no need to double bundle.\r\n/// <reference path=\"../../navmesh/src/javascript-astar.d.ts\" />\r\nimport NavMesh from \"navmesh/src\";\r\nimport Phaser from \"phaser\";\r\n/**\r\n * A wrapper around {@link NavMesh} for Phaser 3. Create instances of this class from\r\n * {@link PhaserNavMeshPlugin}. This is the workhorse that represents a navigation mesh built from a\r\n * series of polygons. Once built, the mesh can be asked for a path from one point to another point.\r\n *\r\n * Compared to {@link NavMesh}, this adds visual debugging capabilities and converts paths to\r\n * Phaser-compatible point instances.\r\n *\r\n * @export\r\n * @class PhaserNavMesh\r\n */\r\nexport default class PhaserNavMesh {\r\n    /**\r\n     * Creates an instance of PhaserNavMesh.\r\n     * @param plugin The plugin that owns this mesh.\r\n     * @param scene\r\n     * @param key The key the mesh is stored under within the plugin.\r\n     * @param meshPolygonPoints Array where each element is an array of point-like objects that\r\n     * defines a polygon.\r\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\r\n     * obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\r\n    constructor(plugin, scene, key, meshPolygonPoints, meshShrinkAmount = 0) {\r\n        this.key = key;\r\n        this.plugin = plugin;\r\n        this.scene = scene;\r\n        this.debugGraphics = null;\r\n        this.navMesh = new NavMesh(meshPolygonPoints, meshShrinkAmount);\r\n    }\r\n    /**\r\n     * Find if the given point is within any of the polygons in the mesh.\r\n     * @param point\r\n     */\r\n    isPointInMesh(point) {\r\n        return this.navMesh.isPointInMesh(point);\r\n    }\r\n    /**\r\n     * See {@link NavMesh#findPath}. This implements the same functionality, except that the returned\r\n     * path is converted to Phaser-compatible points.\r\n     * @param startPoint A point-like object\r\n     * @param endPoint A point-like object\r\n     * @param PointClass The class used to represent points in the final path\r\n     * @returns An array of points if a path is found, or null if no path\r\n     */\r\n    findPath(startPoint, endPoint, PointClass = Phaser.Geom.Point) {\r\n        const path = this.navMesh.findPath(startPoint, endPoint);\r\n        return path ? path.map(({ x, y }) => new PointClass(x, y)) : path;\r\n    }\r\n    /**\r\n     * Enable the debug drawing graphics. If no graphics object is provided, a new instance will be\r\n     * created.\r\n     * @param graphics An optional graphics object for the mesh to use for debug drawing. Note, the\r\n     * mesh will destroy this graphics object when the mesh is destroyed.\r\n     * @returns The graphics object this mesh uses.\r\n     */\r\n    enableDebug(graphics) {\r\n        if (!graphics && !this.debugGraphics) {\r\n            this.debugGraphics = this.scene.add.graphics();\r\n        }\r\n        else if (graphics) {\r\n            if (this.debugGraphics)\r\n                this.debugGraphics.destroy();\r\n            this.debugGraphics = graphics;\r\n        }\r\n        this.debugGraphics.visible = true;\r\n        return this.debugGraphics;\r\n    }\r\n    /** Hide the debug graphics, but don't destroy it. */\r\n    disableDebug() {\r\n        if (this.debugGraphics)\r\n            this.debugGraphics.visible = false;\r\n    }\r\n    /** Returns true if the debug graphics object is enabled and visible. */\r\n    isDebugEnabled() {\r\n        return this.debugGraphics && this.debugGraphics.visible;\r\n    }\r\n    /** Clear the debug graphics. */\r\n    debugDrawClear() {\r\n        if (this.debugGraphics)\r\n            this.debugGraphics.clear();\r\n    }\r\n    /**\r\n     * Visualize the polygons in the navmesh by drawing them to the debug graphics.\r\n     * @param options\r\n     * @param [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param [options.drawNeighbors=true] For each polygon, show the connections to neighbors\r\n     * @param [options.drawPortals=true] For each polygon, show the portal edges\r\n     * @param [options.palette=[0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951]] An array of\r\n     * Phaser-compatible format colors to use when drawing the individual polygons. The first poly\r\n     * uses the first color, the second poly uses the second color, etc.\r\n     */\r\n    debugDrawMesh({ drawCentroid = true, drawBounds = false, drawNeighbors = true, drawPortals = true, palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951], } = {}) {\r\n        if (!this.debugGraphics)\r\n            return;\r\n        const graphics = this.debugGraphics;\r\n        const navPolys = this.navMesh.getPolygons();\r\n        navPolys.forEach((poly) => {\r\n            const color = palette[poly.id % palette.length];\r\n            graphics.fillStyle(color);\r\n            graphics.fillPoints(poly.getPoints(), true);\r\n            if (drawCentroid) {\r\n                graphics.fillStyle(0x000000);\r\n                graphics.fillCircle(poly.centroid.x, poly.centroid.y, 4);\r\n            }\r\n            if (drawBounds) {\r\n                graphics.lineStyle(1, 0xffffff);\r\n                graphics.strokeCircle(poly.centroid.x, poly.centroid.y, poly.boundingRadius);\r\n            }\r\n            if (drawNeighbors) {\r\n                graphics.lineStyle(2, 0x000000);\r\n                poly.neighbors.forEach((n) => {\r\n                    graphics.lineBetween(poly.centroid.x, poly.centroid.y, n.centroid.x, n.centroid.y);\r\n                });\r\n            }\r\n            if (drawPortals) {\r\n                graphics.lineStyle(10, 0x000000);\r\n                poly.portals.forEach((portal) => graphics.lineBetween(portal.start.x, portal.start.y, portal.end.x, portal.end.y));\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Visualize a path (array of points) on the debug graphics.\r\n     * @param path Array of point-like objects in the form {x, y}\r\n     * @param color\r\n     * @param thickness\r\n     * @param alpha\r\n     */\r\n    debugDrawPath(path, color = 0x00ff00, thickness = 10, alpha = 1) {\r\n        if (!this.debugGraphics)\r\n            return;\r\n        if (path && path.length) {\r\n            // Draw line for path\r\n            this.debugGraphics.lineStyle(thickness, color, alpha);\r\n            this.debugGraphics.strokePoints(path);\r\n            // Draw circle at start and end of path\r\n            this.debugGraphics.fillStyle(color, alpha);\r\n            const d = 1.2 * thickness;\r\n            this.debugGraphics.fillCircle(path[0].x, path[0].y, d);\r\n            if (path.length > 1) {\r\n                const lastPoint = path[path.length - 1];\r\n                this.debugGraphics.fillCircle(lastPoint.x, lastPoint.y, d);\r\n            }\r\n        }\r\n    }\r\n    /** Destroy the mesh, kill the debug graphic and unregister itself with the plugin. */\r\n    destroy() {\r\n        if (this.navMesh)\r\n            this.navMesh.destroy();\r\n        if (this.debugGraphics)\r\n            this.debugGraphics.destroy();\r\n        this.plugin.removeMesh(this.key);\r\n    }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./navpoly\";\r\nimport NavGraph from \"./navgraph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear, projectPointToEdge } from \"./utils\";\r\nimport Vector2 from \"./math/vector-2\";\r\nimport Line from \"./math/line\";\r\nimport Polygon from \"./math/polygon\";\r\n/**\r\n * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of\r\n * polygons. Once built, the mesh can be asked for a path from one point to another point. Some\r\n * internal terminology usage:\r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nexport default class NavMesh {\r\n    /**\r\n     * @param meshPolygonPoints Array where each element is an array of point-like objects that\r\n     * defines a polygon.\r\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\r\n     * obstacles (a.k.a the amount obstacles have been expanded).\r\n     */\r\n    constructor(meshPolygonPoints, meshShrinkAmount = 0) {\r\n        this.meshShrinkAmount = meshShrinkAmount;\r\n        // Convert the PolyPoints[] into NavPoly instances.\r\n        const newPolys = meshPolygonPoints.map((polyPoints) => {\r\n            const vectors = polyPoints.map((p) => new Vector2(p.x, p.y));\r\n            return new Polygon(vectors);\r\n        });\r\n        this.navPolygons = newPolys.map((polygon, i) => new NavPoly(i, polygon));\r\n        this.calculateNeighbors();\r\n        // Astar graph of connections between polygons\r\n        this.graph = new NavGraph(this.navPolygons);\r\n    }\r\n    /**\r\n     * Get the NavPolys that are in this navmesh.\r\n     */\r\n    getPolygons() {\r\n        return this.navPolygons;\r\n    }\r\n    /**\r\n     * Cleanup method to remove references.\r\n     */\r\n    destroy() {\r\n        this.graph.destroy();\r\n        for (const poly of this.navPolygons)\r\n            poly.destroy();\r\n        this.navPolygons = [];\r\n    }\r\n    /**\r\n     * Find if the given point is within any of the polygons in the mesh.\r\n     * @param point\r\n     */\r\n    isPointInMesh(point) {\r\n        return this.navPolygons.some((navPoly) => navPoly.contains(point));\r\n    }\r\n    /**\r\n     * Find the closest point in the mesh to the given point. If the point is already in the mesh,\r\n     * this will give you that point. If the point is outside of the mesh, this will attempt to\r\n     * project this point into the mesh (up to the given maxAllowableDist). This returns an object\r\n     * with:\r\n     * - distance - from the given point to the mesh\r\n     * - polygon - the one the point is closest to, or null\r\n     * - point - the point inside the mesh, or null\r\n     * @param point\r\n     * @param maxAllowableDist\r\n     */\r\n    findClosestMeshPoint(point, maxAllowableDist = Number.POSITIVE_INFINITY) {\r\n        let minDistance = maxAllowableDist;\r\n        let closestPoly = null;\r\n        let pointOnClosestPoly = null;\r\n        for (const navPoly of this.navPolygons) {\r\n            // If we are inside a poly, we've got the closest.\r\n            if (navPoly.contains(point)) {\r\n                minDistance = 0;\r\n                closestPoly = navPoly;\r\n                pointOnClosestPoly = point;\r\n                break;\r\n            }\r\n            // Is the poly close enough to warrant a more accurate check? Point is definitely outside of\r\n            // the polygon. Distance - Radius is the smallest possible distance to an edge of the poly.\r\n            // This will underestimate distance, but that's perfectly fine.\r\n            const r = navPoly.boundingRadius;\r\n            const d = navPoly.centroid.distance(point);\r\n            if (d - r < minDistance) {\r\n                const result = this.projectPointToPolygon(point, navPoly);\r\n                if (result.distance < minDistance) {\r\n                    minDistance = result.distance;\r\n                    closestPoly = navPoly;\r\n                    pointOnClosestPoly = result.point;\r\n                }\r\n            }\r\n        }\r\n        return { distance: minDistance, polygon: closestPoly, point: pointOnClosestPoly };\r\n    }\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     * @param {object} startPoint A point-like object in the form {x, y}\r\n     * @param {object} endPoint A point-like object in the form {x, y}\r\n     * @returns {Vector2[]|null} An array of points if a path is found, or null if no path\r\n     */\r\n    findPath(startPoint, endPoint) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n        const startVector = new Vector2(startPoint.x, startPoint.y);\r\n        const endVector = new Vector2(endPoint.x, endPoint.y);\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this.navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startVector);\r\n            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endVector);\r\n            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n        // If the end point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!endPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endVector);\r\n                if (d <= r) {\r\n                    const { distance } = this.projectPointToPolygon(endVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the end, so no path found\r\n        // because start point is valid normally, check end point first\r\n        if (!endPoly)\r\n            return null;\r\n        // Same check as above, but for the start point\r\n        if (!startPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startVector);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const { distance } = this.projectPointToPolygon(startVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the start, so no path found\r\n        if (!startPoly)\r\n            return null;\r\n        // If the start and end polygons are the same, return a direct path\r\n        if (startPoly === endPoly)\r\n            return [startVector, endVector];\r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this.graph, startPoly, endPoly, {\r\n            heuristic: this.graph.navHeuristic,\r\n        });\r\n        // While the start and end polygons may be valid, no path between them\r\n        if (astarPath.length === 0)\r\n            return null;\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startVector);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n            if (!portal)\r\n                throw new Error(\"Path was supposed to be found, but portal is missing!\");\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endVector);\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint))\r\n                phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n        return phaserPath;\r\n    }\r\n    calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this.navPolygons.length; i++) {\r\n            const navPoly = this.navPolygons[i];\r\n            for (let j = i + 1; j < this.navPolygons.length; j++) {\r\n                const otherNavPoly = this.navPolygons[j];\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)\r\n                    continue;\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge))\r\n                            continue;\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this.getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap)\r\n                            continue;\r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            { line: line1, point: line1.start },\r\n            { line: line1, point: line1.end },\r\n            { line: line2, point: line2.start },\r\n            { line: line2, point: line2.end },\r\n        ];\r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x)\r\n                return -1;\r\n            else if (a.point.x > b.point.x)\r\n                return 1;\r\n            else {\r\n                if (a.point.y < b.point.y)\r\n                    return -1;\r\n                else if (a.point.y > b.point.y)\r\n                    return 1;\r\n                else\r\n                    return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a\r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap)\r\n            return null;\r\n        else\r\n            return [points[1].point, points[2].point];\r\n    }\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     *\r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     */\r\n    projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return { point: closestProjection, distance: closestDistance };\r\n    }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n * @private\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.grid = [];\r\n        this.init = jsastar.Graph.prototype.init.bind(this);\r\n        this.cleanDirty = jsastar.Graph.prototype.cleanDirty.bind(this);\r\n        this.markDirty = jsastar.Graph.prototype.markDirty.bind(this);\r\n        this.toString = jsastar.Graph.prototype.toString.bind(this);\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n}\r\nexport default NavGraph;\r\n","/**\r\n * Internal helper class to manage a queue of points when parsing a square map.\r\n */\r\nexport class PointQueue {\r\n    constructor() {\r\n        this.data = [];\r\n    }\r\n    add(point) {\r\n        this.data.push(point);\r\n    }\r\n    shift() {\r\n        return this.data.shift();\r\n    }\r\n    isEmpty() {\r\n        return this.data.length === 0;\r\n    }\r\n    containsPoint(point) {\r\n        return this.data.find((p) => p.x === point.x && p.y === point.y) !== undefined ? true : false;\r\n    }\r\n    containsAllPoints(points) {\r\n        return points.every((p) => this.containsPoint(p));\r\n    }\r\n    getIndexOfPoint(point) {\r\n        return this.data.findIndex((p) => p.x == point.x && p.y == point.y);\r\n    }\r\n    removePoint(point) {\r\n        const index = this.getIndexOfPoint(point);\r\n        if (index !== -1)\r\n            this.data.splice(index, 1);\r\n    }\r\n    removePoints(points) {\r\n        points.forEach((p) => this.removePoint(p));\r\n    }\r\n}\r\n","/**\r\n * Class for managing hulls created by combining square tiles.\r\n */\r\nexport class RectangleHull {\r\n    constructor(left, top, right, bottom) {\r\n        this.left = left;\r\n        this.right = right;\r\n        this.top = top;\r\n        this.bottom = bottom;\r\n        this.tiles = [];\r\n    }\r\n    forEachTopPoint(fn) {\r\n        for (let x = this.left; x <= this.right; x++)\r\n            fn(x, this.top);\r\n    }\r\n    forEachBottomPoint(fn) {\r\n        for (let x = this.left; x <= this.right; x++)\r\n            fn(x, this.bottom);\r\n    }\r\n    forEachLeftPoint(fn) {\r\n        for (let y = this.top; y <= this.bottom; y++)\r\n            fn(this.left, y);\r\n    }\r\n    forEachRightPoint(fn) {\r\n        for (let y = this.top; y <= this.bottom; y++)\r\n            fn(this.right, y);\r\n    }\r\n}\r\n","import { isTruthy } from \"../utils\";\r\nimport { PointQueue } from \"./point-queue\";\r\nimport { RectangleHull } from \"./rectangle-hull\";\r\n/**\r\n * This parses a world that is a uniform grid into convex polygons (specifically rectangles) that\r\n * can be used for building a navmesh. This is designed mainly for parsing tilemaps into polygons.\r\n * The functions takes a 2D array that indicates which tiles are walkable and which aren't. The\r\n * function returns PolyPoint[] that can be used to construct a NavMesh.\r\n *\r\n * Notes:\r\n * - This algorithm traverses the walkable tiles in a depth-first search, combining neighbors into\r\n *   rectangular polygons. This may not produce the best navmesh, but it doesn't require any manual\r\n *   work!\r\n * - This assumes the world is a uniform grid. It should work for any tile size, provided that all\r\n *   tiles are the same width and height.\r\n *\r\n * @param map 2D array of any type.\r\n * @param tileWidth The width of each tile in the grid.\r\n * @param tileHeight The height of each tile in the grid.\r\n * @param isWalkable Function that is used to test if a specific location in the map is walkable.\r\n * Defaults to assuming \"truthy\" means walkable.\r\n */\r\nexport default function buildPolysFromGridMap(map, tileWidth = 1, tileHeight = 1, isWalkable = isTruthy) {\r\n    const walkableQueue = new PointQueue();\r\n    const hulls = [];\r\n    let currentHull;\r\n    // Build up the queue of walkable tiles.\r\n    map.forEach((row, y) => {\r\n        row.forEach((col, x) => {\r\n            if (isWalkable(col, x, y))\r\n                walkableQueue.add({ x, y });\r\n        });\r\n    });\r\n    const getExtensionPoints = (hull, dir) => {\r\n        const points = [];\r\n        if (dir === \"top\")\r\n            hull.forEachTopPoint((x, y) => points.push({ x, y: y - 1 }));\r\n        else if (dir === \"bottom\")\r\n            hull.forEachBottomPoint((x, y) => points.push({ x, y: y + 1 }));\r\n        else if (dir === \"left\")\r\n            hull.forEachLeftPoint((x, y) => points.push({ x: x - 1, y }));\r\n        else if (dir === \"right\")\r\n            hull.forEachRightPoint((x, y) => points.push({ x: x + 1, y }));\r\n        else\r\n            throw new Error(`Invalid dir \"${dir}\" for extend`);\r\n        return points;\r\n    };\r\n    const extendHullInDirection = (hull, dir) => {\r\n        if (dir === \"top\")\r\n            hull.top -= 1;\r\n        else if (dir === \"bottom\")\r\n            hull.bottom += 1;\r\n        else if (dir === \"left\")\r\n            hull.left -= 1;\r\n        else if (dir === \"right\")\r\n            hull.right += 1;\r\n        else\r\n            throw new Error(`Invalid dir \"${dir}\" for extend`);\r\n    };\r\n    const attemptExtension = (hull, dir) => {\r\n        const neighborPoints = getExtensionPoints(hull, dir);\r\n        const canExtend = walkableQueue.containsAllPoints(neighborPoints);\r\n        if (canExtend) {\r\n            extendHullInDirection(hull, dir);\r\n            hull.tiles.push(...neighborPoints);\r\n            walkableQueue.removePoints(neighborPoints);\r\n        }\r\n        return canExtend;\r\n    };\r\n    while (!walkableQueue.isEmpty()) {\r\n        // Find next colliding tile to start the algorithm.\r\n        const tile = walkableQueue.shift();\r\n        if (tile === undefined)\r\n            break;\r\n        currentHull = new RectangleHull(0, 0, 0, 0);\r\n        currentHull.left = tile.x;\r\n        currentHull.right = tile.x;\r\n        currentHull.top = tile.y;\r\n        currentHull.bottom = tile.y;\r\n        currentHull.tiles.push(tile);\r\n        // Check edges of bounding box to see if they can be extended.\r\n        let needsExtensionCheck = true;\r\n        while (needsExtensionCheck) {\r\n            const extendedTop = attemptExtension(currentHull, \"top\");\r\n            const extendedBottom = attemptExtension(currentHull, \"bottom\");\r\n            const extendedLeft = attemptExtension(currentHull, \"left\");\r\n            const extendedRight = attemptExtension(currentHull, \"right\");\r\n            needsExtensionCheck = extendedTop || extendedBottom || extendedLeft || extendedRight;\r\n        }\r\n        hulls.push(currentHull);\r\n    }\r\n    const polygons = hulls.map((hull) => {\r\n        const left = hull.left * tileWidth;\r\n        const top = hull.top * tileHeight;\r\n        const right = (hull.right + 1) * tileWidth;\r\n        const bottom = (hull.bottom + 1) * tileHeight;\r\n        return [\r\n            { x: left, y: top },\r\n            { x: left, y: bottom },\r\n            { x: right, y: bottom },\r\n            { x: right, y: top },\r\n        ];\r\n    });\r\n    return polygons;\r\n}\r\n","import Phaser from \"phaser\";\r\nimport PhaserNavMesh from \"./phaser-navmesh\";\r\nimport { buildPolysFromGridMap } from \"navmesh/src/map-parsers\";\r\n/**\r\n * This class can create navigation meshes for use in Phaser 3. The navmeshes can be constructed\r\n * from convex polygons embedded in a Tiled map. The class that conforms to Phaser 3's plugin\r\n * structure.\r\n *\r\n * @export\r\n * @class PhaserNavMeshPlugin\r\n */\r\nexport default class PhaserNavMeshPlugin extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n        this.phaserNavMeshes = {};\r\n    }\r\n    /** Phaser.Scene lifecycle event */\r\n    boot() {\r\n        const emitter = this.systems.events;\r\n        emitter.once(\"destroy\", this.destroy, this);\r\n    }\r\n    /** Phaser.Scene lifecycle event - noop in this plugin, but still required. */\r\n    init() { }\r\n    /** Phaser.Scene lifecycle event - noop in this plugin, but still required.*/\r\n    start() { }\r\n    /** Phaser.Scene lifecycle event - will destroy all navmeshes created. */\r\n    destroy() {\r\n        this.systems.events.off(\"boot\", this.boot, this);\r\n        this.removeAllMeshes();\r\n    }\r\n    /**\r\n     * Remove all the meshes from the navmesh.\r\n     */\r\n    removeAllMeshes() {\r\n        const meshes = Object.values(this.phaserNavMeshes);\r\n        this.phaserNavMeshes = {};\r\n        meshes.forEach((m) => m.destroy());\r\n    }\r\n    /**\r\n     * Remove the navmesh stored under the given key from the plugin. This does not destroy the\r\n     * navmesh.\r\n     * @param key\r\n     */\r\n    removeMesh(key) {\r\n        if (this.phaserNavMeshes[key])\r\n            delete this.phaserNavMeshes[key];\r\n    }\r\n    /**\r\n     * This method attempts to automatically build a navmesh based on the give tilemap and tilemap\r\n     * layer(s). It attempts to respect the x/y position and scale of the layer(s). Important note: it\r\n     * doesn't support rotation/flip or multiple layers that have different positions/scales.\r\n     *\r\n     * @param key Key to use when storing this navmesh within the plugin.\r\n     * @param tilemap The tilemap to use for building the navmesh.\r\n     * @param tilemapLayers An optional array of tilemap layers to use for building the mesh.\r\n     * @param isWalkable An optional function to use to test if a tile is walkable. Defaults to\r\n     * assuming non-colliding tiles are walkable.\r\n     */\r\n    buildMeshFromTilemap(key, tilemap, tilemapLayers, isWalkable) {\r\n        // TODO: factor in shrink\r\n        // Use all layers in map, or just the specified ones.\r\n        const dataLayers = tilemapLayers ? tilemapLayers.map((tl) => tl.layer) : tilemap.layers;\r\n        if (!isWalkable)\r\n            isWalkable = (tile) => !tile.collides;\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n        let scaleX = 1;\r\n        let scaleY = 1;\r\n        // Attempt to set position offset and scale from the 1st tilemap layer given.\r\n        if (tilemapLayers) {\r\n            const layer = tilemapLayers[0];\r\n            offsetX = layer.tileToWorldX(0);\r\n            offsetY = layer.tileToWorldY(0);\r\n            scaleX = layer.scaleX;\r\n            scaleY = layer.scaleY;\r\n            // Check and warn for layer settings that will throw off the calculation.\r\n            for (const layer of tilemapLayers) {\r\n                if (offsetX !== layer.tileToWorldX(0) ||\r\n                    offsetY !== layer.tileToWorldY(0) ||\r\n                    scaleX !== layer.scaleX ||\r\n                    scaleY !== layer.scaleY) {\r\n                    console.warn(`PhaserNavMeshPlugin: buildMeshFromTilemap reads position & scale from the 1st TilemapLayer. Layer index ${layer.layerIndex} has a different position & scale from the 1st TilemapLayer.`);\r\n                }\r\n                if (layer.rotation !== 0) {\r\n                    console.warn(`PhaserNavMeshPlugin: buildMeshFromTilemap doesn't support TilemapLayer with rotation. Layer index ${layer.layerIndex} is rotated.`);\r\n                }\r\n            }\r\n        }\r\n        // Check and warn about DataLayer that have x/y position from Tiled. In the future, these could\r\n        // be supported if A) only one colliding layer is offset, or B) the offset is a multiple of the\r\n        // tile size.\r\n        dataLayers.forEach((layer) => {\r\n            if (layer.x !== 0 || layer.y !== 0) {\r\n                console.warn(`PhaserNavMeshPlugin: buildMeshFromTilemap doesn't support layers with x/y positions from Tiled.`);\r\n            }\r\n        });\r\n        // Build 2D array of walkable tiles across all given layers.\r\n        const walkableAreas = [];\r\n        for (let ty = 0; ty < tilemap.height; ty += 1) {\r\n            const row = [];\r\n            for (let tx = 0; tx < tilemap.width; tx += 1) {\r\n                let walkable = true;\r\n                for (const layer of dataLayers) {\r\n                    const tile = layer.data[ty][tx];\r\n                    if (tile && !isWalkable(tile)) {\r\n                        walkable = false;\r\n                        break;\r\n                    }\r\n                }\r\n                row.push(walkable);\r\n            }\r\n            walkableAreas.push(row);\r\n        }\r\n        let polygons = buildPolysFromGridMap(walkableAreas, tilemap.tileWidth, tilemap.tileHeight);\r\n        // Offset and scale each polygon if necessary.\r\n        if (scaleX !== 1 && scaleY !== 1 && offsetX !== 0 && offsetY !== 0) {\r\n            polygons = polygons.map((poly) => poly.map((p) => ({ x: p.x * scaleX + offsetX, y: p.y * scaleY + offsetY })));\r\n        }\r\n        const mesh = new PhaserNavMesh(this, this.scene, key, polygons, 0);\r\n        this.phaserNavMeshes[key] = mesh;\r\n        return mesh;\r\n    }\r\n    /**\r\n     * Load a navmesh from Tiled. Currently assumes that the polygons are squares! Does not support\r\n     * tilemap layer scaling, rotation or position.\r\n     * @param key Key to use when storing this navmesh within the plugin.\r\n     * @param objectLayer The ObjectLayer from a tilemap that contains the polygons that make up the\r\n     * navmesh.\r\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\r\n     * obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\r\n    buildMeshFromTiled(key, objectLayer, meshShrinkAmount = 0) {\r\n        if (this.phaserNavMeshes[key]) {\r\n            console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${key}`);\r\n            return this.phaserNavMeshes[key];\r\n        }\r\n        if (!objectLayer || objectLayer.objects.length === 0) {\r\n            console.warn(`NavMeshPlugin: The given tilemap object layer is empty or undefined: ${objectLayer}`);\r\n        }\r\n        const objects = objectLayer.objects ?? [];\r\n        // Loop over the objects and construct a polygon - assumes a rectangle for now!\r\n        // TODO: support layer position, scale, rotation\r\n        const polygons = objects.map((obj) => {\r\n            const h = obj.height ?? 0;\r\n            const w = obj.width ?? 0;\r\n            const left = obj.x ?? 0;\r\n            const top = obj.y ?? 0;\r\n            const bottom = top + h;\r\n            const right = left + w;\r\n            return [\r\n                { x: left, y: top },\r\n                { x: left, y: bottom },\r\n                { x: right, y: bottom },\r\n                { x: right, y: top },\r\n            ];\r\n        });\r\n        const mesh = new PhaserNavMesh(this, this.scene, key, polygons, meshShrinkAmount);\r\n        console.log(polygons.length);\r\n        this.phaserNavMeshes[key] = mesh;\r\n        return mesh;\r\n    }\r\n}\r\n","/**\r\n * `phaser-navmesh` is a Phaser v3 wrapper around `navmesh` that creates a Phaser 3 Scene plugin.\r\n * Phaser 3 is expected to be a dependency in your project.\r\n * @packageDocumentation\r\n * @module phaser-navmesh\r\n */\r\nimport PhaserNavMeshPlugin from \"./phaser-navmesh-plugin\";\r\nimport PhaserNavMesh from \"./phaser-navmesh\";\r\nexport { PhaserNavMeshPlugin, PhaserNavMesh };\r\nexport default PhaserNavMeshPlugin;\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__445__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(179);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))"],"sourceRoot":""}